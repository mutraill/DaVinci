# -*- coding: utf-8 -*-

# DaVinci script to apply Stripping 21 cuts with PID requirements to MC  
# Decays of Xicc+ -> (D+ -> K- pi+ pi+) D+ p+ K-] generated by GenXicc package

__author__  = 'Murdo Traill'
__date__    =  '23/11/2016'

########## IMPORT BASIC CLASSES ###################

import GaudiKernel.SystemOfUnits as Units

from Gaudi.Configuration import *
from PhysSelPython.Wrappers import AutomaticData, Selection, DataOnDemand, SelectionSequence

########## CANDIDATE LOCATION ####################

line = 'XiccXiccPlusToDpPK'                        # The stripping line of choice
location = '/Event/Charm/Phys/'+line+'/Particles'  # Used for debugging later on 

######## BUILD THE DPLUS DECAY ###################

from Configurables import CombineParticles

# Define Algorithm '_D2KPiPi' with the following cuts to constrain the Dplus candidates.

_D2KPiPi = CombineParticles("D2KPiPi",                       
				    DecayDescriptor = "[D+ -> K- pi+ pi+]cc",
		        DaughtersCuts = { 'K+' : '(P > 2*GeV)', 'pi+' : '(P > 2*GeV)' },
			      CombinationCut = "(AM>1760.*MeV) & (AM<2080.*MeV) & ((APT>1.*GeV) | (ASUM(PT)>1.*GeV)) & (ADOCAMAX('')<0.5*mm)",
            MotherCut = "(VFASPF(VCHI2) < 30 ) & (M>1770.*MeV) & (M < 2070.*MeV) & (BPVVDCHI2>36) & (BPVDIRA>0.98)")

# Locate protoparticles from TES for kaons and pions. 

from CommonParticles import StdAllNoPIDsKaons, StdAllNoPIDsPions, StdAllNoPIDsProtons

Kaons  = DataOnDemand(Location = 'Phys/StdNoPIDsKaons/Particles')
Pions = DataOnDemand(Location = 'Phys/StdNoPIDsPions/Particles')
Protons = DataOnDemand(Location = 'Phys/StdNoPIDsProtons/Particles')

AllKaons  = DataOnDemand(Location = 'Phys/StdAllNoPIDsKaons/Particles')

# Make a selection object for the Dplus candidates using the algorithm defined above, feeding in the protoparticles. 

Sel_LooseDplus2KPiPi = Selection("Sel_LooseDplus2kPiPi", 
                              Algorithm = _D2KPiPi, 
                              RequiredSelections = [Kaons, Pions])

# Define next the algorithm '_dplusfilter' which will place further cuts on the Dplus candidates.

from Configurables import FilterDesktop 
                   
_dplusfilter = FilterDesktop("_dplusFilter",
                       Code = "(ADMASS('D+')<75.0) & (BPVVDCHI2>100.0)")

# Make another Selection object for filtered Dplus candidates using '_dplusfilter' algorithm.
                 
Sel_Dplus2KPiPi = Selection("Sel_Dplus2KPiPi",
                      Algorithm = _dplusfilter,
                      RequiredSelections = [Sel_LooseDplus2KPiPi])
                      
############# BUILD THE XICC DECAY #######################

# Locate the protoparticles from TES for the soft protons. 

AllProtons = DataOnDemand(Location = 'Phys/StdAllNoPIDsProtons/Particles')

# Define the algorithm '_pfilter' with cuts for the protons. 

_Pfilter = FilterDesktop("_PFilter",
	              Code = "(TRCHI2DOF<5.0) & (P>2000.0) & (PT>250.0) & (MIPCHI2DV(PRIMARY)>-1.0)")

# Make a selection object for the filtered protons, feeding in the protoparticles. 

Sel_FilterProtons = Selection("Sel_FilterProtons", 
                          Algorithm = _Pfilter,
                          RequiredSelections = [AllProtons])

# Define the algorithm '_Kfilter' with cuts for the soft kaons. 

_Kfilter = FilterDesktop("_KFilter",
	              Code = "(TRCHI2DOF<5.0)& (P>2000.0) & (PT>250.0)& (MIPCHI2DV(PRIMARY)>-1.0)")

# Make a selection object for the filtered kaons, feeding in the protoparticles. 

Sel_FilterKaons = Selection("Sel_FilterKaons", 
                          Algorithm = _Kfilter,
                          RequiredSelections = [AllKaons])
                                   
# Define the TisTosParticle Tagger Algorithm '_XiccDplusTisTos" for determining if Dplus Candidate are TIS or TOS.                           
                          
from Configurables import TisTosParticleTagger

_XiccDplusTisTos = TisTosParticleTagger("XiccPlusTisTos", TisTosSpecs = { 'Hlt2.*CharmHadD2HHH.*Decision%TOS' : 0 })

# Make a selection object for the TISTOS result of the filtered Dplus candidates. 

Sel_XiccDplusTisTos = Selection("Sel_XiccDplusTisTos", 
							Algorithm = _XiccDplusTisTos, 
							RequiredSelections = [Sel_Dplus2KPiPi])
							
# Define the algorithm '_Xiccplus2DplusKp' with the following cut to constrain the Xicc candidates. 

_Xiccplus2DplusKp = CombineParticles("_Xiccplus2DplusKp",
							DecayDescriptor = "[Xi_cc+ -> D+ p+ K-]cc",
							DaughtersCuts = { '' : 'ALL' , 'D+' : 'ALL' , 'D-' : 'ALL' , 'K+' : 'ALL' , 'K-' : 'ALL' , 'p+' : 'ALL' , 'p~-' : 'ALL' },
							CombinationCut = "(AM<4000.0)& (APT>2000.0)& (ADOCAMAX('')<0.5)",
							MotherCut = "(VFASPF(VCHI2)<30.0)&(CHILD(VFASPF(VZ),1) - VFASPF(VZ) > 0.01)& (BPVVDCHI2 > -1.0)& (BPVDIRA > 0.0)")
		
# Make a selection object for the final Xicc candidates with the above algorithm. 				

Sel_Xicc = Selection("Xicc+_Sel", Algorithm = _Xiccplus2DplusKp, RequiredSelections = [Sel_XiccDplusTisTos, Sel_FilterProtons, Sel_FilterKaons]) 

# Configure the order of selections to be carried out in sequentially with the last selection at the top. 

Seq_Xicc2DplusKp = SelectionSequence("Seq_Xicc2DplusKp" , TopSelection = Sel_Xicc )

###################### CONFIGURE DECAY TREE TUPLE ###########################

# Using DecayTreeTuple to give reconstructed information in our final ntuple 

from Configurables import DecayTreeTuple, TupleToolTrigger, TupleToolDecay, TupleToolTISTOS
from DecayTreeTuple.Configuration import *

simulation = True

tuple = DecayTreeTuple() 
tuple.Decay = "[Xi_cc+ -> ^(D+ -> ^K- ^pi+ ^pi+) ^p+ ^K-]CC"

# Input is the resulting of the stripping the candidates
tuple.Inputs = [Seq_Xicc2DplusKp.outputLocation()]

tuple.ToolList +=  [
      "TupleToolGeometry"
    , "TupleToolKinematic"
    , "TupleToolEventInfo"
    , "TupleToolTrackInfo"  
    , "TupleToolPrimaries"
    , "TupleToolTISTOS"
    , "TupleToolAngles"
    , "TupleToolPid"
    , "TupleToolPropertime"]

if (simulation):
  tuple.addTupleTool("TupleToolMCTruth")
  tuple.addTupleTool("TupleToolMCBackgroundInfo")

# Change the configuration of the TupleToolTISTOS tool 
tuple.addTool(TupleToolTISTOS())
tuple.TupleToolTISTOS.TriggerList = ["Hlt1TrackAllL0Decision",
                                     "Hlt1GlobalDecision",
                                     "Hlt2CharmHadD2HHHDecision",
                                     "Hlt2CharmHadD2HHHWideMassDecision",
                                     "Hlt2CharmHadD2HHHKsDDDecision",
                                     "Hlt2CharmHadD2HHHKsLLDecision"]

tuple.TupleToolTISTOS.VerboseOBHlt1 = True
tuple.TupleToolTISTOS.VerboseHlt2 = True

# Personalise particle branch head names
tuple.addBranches({'Xicc'     : '[Xi_cc+ -> (D+ -> K- pi+ pi+) p+ K-]CC',
                   'Dplus'    : '[Xi_cc+ -> ^(D+ -> K- pi+ pi+) p+ K-]CC',
                   'Kminus'   : '[Xi_cc+ -> (D+ -> ^K- pi+ pi+) p+ K-]CC',
                   'piplus1'  : '[Xi_cc+ -> (D+ -> K- ^pi+ pi+) p+ K-]CC',
                   'piplus2'  : '[Xi_cc+ -> (D+ -> K- pi+ ^pi+) p+ K-]CC',
                   'pplus'    : '[Xi_cc+ -> (D+ -> K- pi+ pi+) ^p+ K-]CC',
                   'Ksoft'    : '[Xi_cc+ -> (D+ -> K- pi+ pi+) p+ ^K-]CC'})

# Configure DTF variables with a constraint on the D+ mass and PV constraint

const_tool1 = tuple.Xicc.addTupleTool('TupleToolDecayTreeFitter/ConsDMass')
const_tool1.daughtersToConstrain = ['D+']
const_tool1.Verbose = True

const_tool2 = tuple.Xicc.addTupleTool('TupleToolDecayTreeFitter/ConsPV')
const_tool2.constrainToOriginVertex = True
const_tool2.Verbose = True

#Configure LoKi__Hybrid__TupleTool
from Configurables import LoKi__Hybrid__TupleTool

preamble = ['DZ = VFASPF(VZ) - BPV(VZ)',
            'TRACK_MAX_PT = MAXTREE(ISBASIC & HASTRACK, PT, -1)']

variables1 = {'MAXDOCA'     :  "DOCAMAX",
              'DIRA'        :  "BPVDIRA",
              'DecayAngle'  :  "LV01",
              'P'           :  "P",
              'TRACK_Eta'   :  "ETA",
              'DZ'          :  "DZ",
              'MAX_PT'      :  "TRACK_MAX_PT",
              'VTX_CHI2'    :  "VFASPF(VCHI2)",
              'VTX_VZ'      :  "VFASPF(VZ)",
              'MIPCHI2DV'   :  "MIPCHI2DV(PRIMARY)"}

variables2 = { 'P'           :  "P",
               'TRACK_Eta'   :  "ETA"}

XiccTool = tuple.Xicc.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
XiccTool.Preambulo = preamble
XiccTool.Variables = variables1 

DplusTool = tuple.Dplus.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
DplusTool.Preambulo = preamble
DplusTool.Variables = variables1

KminusTool = tuple.Kminus.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
KminusTool.Preambulo = preamble
KminusTool.Variables = variables2

piplus1Tool = tuple.piplus1.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
piplus1Tool.Preambulo = preamble
piplus1Tool.Variables = variables2

piplus2Tool = tuple.piplus2.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
piplus2Tool.Preambulo = preamble
piplus2Tool.Variables = variables2

psoftTool = tuple.pplus.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
psoftTool.Preambulo = preamble
psoftTool.Variables = variables2

KsoftTool = tuple.Ksoft.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
KsoftTool.Preambulo = preamble
KsoftTool.Variables = variables2

################### CONFIGURE MCDECAY TREE TUPLE ###############################

# Using MCDecayTreeTuple to give generated information in our final ntuple
# Takes no input, stripping candidates are not passed to it as not reconstruction has taken place

mctuple = MCDecayTreeTuple()

mctuple.ToolList +=  [ 
      "MCTupleToolKinematic"
    , "MCTupleToolAngles"
    , "MCTupleToolEventType"
    , "MCTupleToolDecayType"  
    , "MCTupleToolPID"
    , "MCTupleToolPrimaries"
    , "MCTupleToolPrompt"
    , "MCTupleToolInteractions"
    , "MCTupleToolReconstructed"
    , "MCTupleToolHierarchy"]

# Head of generated decay should be Sigma-c and FS photons are simulated by GenXicc package
# '=>' means 'search within the direct daughters, allowing arbitrary number of additional photons

mctuple.Decay = "[Xi_cc+ => ^(D+ => ^K- ^pi+ ^pi+) ^p+ ^K-]CC"

# Personalise particle branch head names
mctuple.addBranches({'Xicc'    : '[Xi_cc+ => (D+ => K- pi+ pi+) p+ K-]CC',
                     'Dplus'   : '[Xi_cc+ => ^(D+ => K- pi+ pi+) p+ K-]CC',
                     'Kminus'  : '[Xi_cc+ => (D+ => ^K- pi+ pi+) p+ K-]CC',
                     'piplus1' : '[Xi_cc+ => (D+ => K- ^pi+ pi+) p+ K-]CC',
                     'piplus2' : '[Xi_cc+ => (D+ => K- pi+ ^pi+) p+ K-]CC',
                     'pplus'   : '[Xi_cc+ => (D+ => K- pi+ pi+) ^p+ K-]CC',
                     'Ksoft'   : '[Xi_cc+ => (D+ => K- pi+ pi+) p+ ^K-]CC'})

####################### CONFIGURE DAVINCI  ###########################

from Configurables import DaVinci

dv = DaVinci()
dv.UserAlgorithms += [Seq_Xicc2DplusKp.sequence(), tuple, mctuple]

dv.DataType = '2012'
dv.InputType = 'DST'
dv.PrintFreq = 1000
dv.EvtMax = -1         

# DDDB = Detector Description Database and CondDB = Conditions Database.

dv.DDDBtag = "dddb-20150928"
dv.CondDBtag = "sim-20160321-2-vc-md100"  # For MagDown
#dv.CondDBtag = "sim-20160321-2-vc-mu100" # For MagUp
   
dv.TupleFile     = "Xicc+2D+pk_MagDown_tuple.root"
dv.Simulation = True
dv.Lumi = not dv.Simulation 

################# DEBUGGING #########################

from Configurables import GaudiSequencer
from Configurables import LoKi__HDRFilter, PrintDecayTree 

MySequencer = GaudiSequencer('Sequence')

pt = PrintDecayTree(Inputs = [ location ])
sf = LoKi__HDRFilter( 'StripPassFilter', Code="HLT_PASS('Stripping"+line+"Decision')", Location="/Event/Strip/Phys/DecReports" )

MySequencer.Members = [ sf ] # Can add 'pt' to this list for debugging 

dv.appendToMainSequence([ MySequencer ])

MessageSvc().Format = "% F%60W%S%7W%R%T %0W%M"  # Useful bit of coding to increase error message output

#####################################################

from GaudiConf import IOHelper

#IOHelper().inputFiles([
#      '/afs/cern.ch/work/m/mutraill/Data/MonteCarlo/Xicc+2D+K-p/MagDown_00053948_00000001_2.AllStreams.dst'
#      ], clear=True)
