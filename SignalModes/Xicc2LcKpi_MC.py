# -*- coding: utf-8 -*-

# DaVinci script to apply Stripping 21 cuts with PID requirements to MC
# Xicc+ -> (Lambda_c+ -> K- p+ pi+) K- pi+ generated by GenXicc package 

__author__  = 'Murdo Traill'
__date__    =  '23/012/2016'

########## IMPORT BASIC CLASSES ###################

import GaudiKernel.SystemOfUnits as Units

from Gaudi.Configuration import *
from PhysSelPython.Wrappers import AutomaticData, Selection, DataOnDemand, SelectionSequence

########## CANDIDATE LOCATION ####################

line = 'XiccXiccPlusToLcKPi'                      # The stripping line of choice
location = '/Event/Charm/Phys/'+line+'/Particles' # For debugging purposes later 

######## BUILD THE D0 DECAY ###################

from Configurables import CombineParticles

# Define Algorithm '_D02PiK' with the following cuts to constrain the Dplus candidates.

_Lc2KPpi = CombineParticles("_LC2KPpi",                       
				    DecayDescriptor = "[Lambda_c+ -> K- p+ pi+]cc",
		        DaughtersCuts = { ''  : 'ALL' , 
                            'K+'  : '(TRCHI2DOF<5.0)& (PT>200.0)& (P>2000.0)' , 
                            'K-'  : '(TRCHI2DOF<5.0)& (PT>200.0)& (P>2000.0)' , 
                            'p+'  : '(TRCHI2DOF<5.0)& (PT>200.0)& (P>2000.0)' , 
                            'pi+' : '(TRCHI2DOF<5.0)& (PT>200.0)& (P>2000.0)' , 
                            'pi-' : '(TRCHI2DOF<5.0)& (PT>200.0)& (P>2000.0)' , 
                            'p~-' : '(TRCHI2DOF<5.0)& (PT>200.0)& (P>2000.0)' },
            CombinationCut = "(ADAMASS('Lambda_c+')<1.1*75.0)& (AMAXCHILD(MIPCHI2DV(PRIMARY))>4.0)& (ADOCAMAX('')<0.5)& (APT>1000.0)",
            MotherCut = "(VFASPF(VCHI2) < 30.0)& (ADMASS('Lambda_c+')<75.0)& (BPVVDCHI2>16.0)& (BPVDIRA>0.99)")

# Locate protoparticles from TES for kaons, protons and pions. 

from CommonParticles import StdAllNoPIDsKaons, StdAllNoPIDsPions, StdAllNoPIDsProtons

Kaons  = DataOnDemand(Location = 'Phys/StdNoPIDsKaons/Particles')
Pions = DataOnDemand(Location = 'Phys/StdNoPIDsPions/Particles')
Protons = DataOnDemand(Location = 'Phys/StdNoPIDsProtons/Particles')

# Make a selection object for the Lambda-c candidates using the algorithm defined above, feeding in the protoparticles. 

Sel_FilteredLc2KPpi = Selection("Sel_FilteredLc2KPpi", 
                              Algorithm = _Lc2KPpi,
                              RequiredSelections = [Kaons,Protons,Pions])
          
############# BUILD THE XICC DECAY #######################

AllKaons  = DataOnDemand(Location = 'Phys/StdAllNoPIDsKaons/Particles')
AllPions = DataOnDemand(Location = 'Phys/StdAllNoPIDsPions/Particles')

# Define the TisTosParticle Tagger Algorithm '_XiccLcTisTos" for determining if Lc Candidate are TIS or TOS.                           
                          
from Configurables import TisTosParticleTagger

_XiccLcTisTos = TisTosParticleTagger("XiccLcTisTos", TisTosSpecs = { 'Hlt2.*CharmHadLambdaC2KPPi.*Decision%TOS' : 0 })

# Make a selection object for the TISTOS result of the filtered Lc candidates. 

Sel_XiccLcTisTos = Selection("Sel_XiccLcTisTos", 
              Algorithm = _XiccLcTisTos, 
              RequiredSelections = [Sel_FilteredLc2KPpi])

# Define the algorithm '_Kfilter' with cuts for the soft kaons. 

from Configurables import FilterDesktop 

_Kfilter = FilterDesktop("_Kfilter",
	              Code = "(TRCHI2DOF<5.0)& (P>2000.0)& (PT>250.0) & (MIPCHI2DV(PRIMARY)>-1.0)")

# Make a selection object for the filtered kaons, feeding in the protoparticles. 

Sel_FilteredKaons = Selection("Sel_FilteredKaons", 
                          Algorithm = _Kfilter,
                          RequiredSelections = [AllKaons])

# Define the algorithm '_Pifilter' with cuts for the soft kaons. 

_Pifilter = FilterDesktop("_Pifilter",
                Code = "(TRCHI2DOF<5.0)& (P>2000.0)& (PT>250.0) & (MIPCHI2DV(PRIMARY)>-1.0)")

# Make a selection object for the filtered pions, feeding in the protoparticles. 

Sel_FilteredPions = Selection("Sel_FilteredPions", 
                          Algorithm = _Pifilter,
                          RequiredSelections = [AllPions])
							
# Define the algorithm '_Xiccplus2D0Kpi' with the following cut to constrain the Xicc candidates. 

_Xiccplus2LcKpi = CombineParticles("_Xiccplus2LcKpi",
							DecayDescriptor = "[Xi_cc+ -> Lambda_c+ K- pi+]cc",
							DaughtersCuts = {'' : 'ALL' , 'K+' : 'ALL' , 'K-' : 'ALL' , 'Lambda_c+' : 'ALL' , 'Lambda_c~-' : 'ALL' , 'pi+' : 'ALL' , 'pi-' : 'ALL' },
							CombinationCut = "(AM<4000.0)& (APT>2000.0)& (ADOCAMAX('')<0.5)",
							MotherCut = "(VFASPF(VCHI2)<30.0)&(CHILD(VFASPF(VZ),1) - VFASPF(VZ) > 0.01)& (BPVVDCHI2 > -1.0)& (BPVDIRA > 0.0)")
	
# Make a selection object for the final Xicc candidates with the above algorithm. 				

Sel_Xicc = Selection("Xicc+_Sel", Algorithm = _Xiccplus2LcKpi, RequiredSelections = [Sel_XiccLcTisTos, Sel_FilteredKaons, Sel_FilteredPions]) 

# Configure the order of selections to be carried out in sequentially with the last selection at the top. 

Seq_Xicc2LcKpi = SelectionSequence("Seq_Xicc2LcKpi" , TopSelection = Sel_Xicc)

###################### CONFIGURE DECAY TREE TUPLE ###########################

# Using DecayTreeTuple to give reconstructed information in our final ntuple 

from Configurables import DecayTreeTuple, TupleToolTrigger, TupleToolDecay, TupleToolTISTOS
from DecayTreeTuple.Configuration import *

simulation = True

tuple = DecayTreeTuple() 
tuple.Decay = "[Xi_cc+ -> ^(Lambda_c+ -> ^K- ^p+ ^pi+) ^K- ^pi+]CC"

# Input is the resulting of the stripping the candidates
tuple.Inputs = [Seq_Xicc2LcKpi.outputLocation()] 

tuple.ToolList +=  [
      "TupleToolGeometry"
    , "TupleToolKinematic"
    , "TupleToolEventInfo"
    , "TupleToolTrackInfo"  
    , "TupleToolPrimaries"
    , "TupleToolTISTOS"
    , "TupleToolAngles"
    , "TupleToolPid"
    , "TupleToolPropertime"]

if (simulation):
  tuple.addTupleTool("TupleToolMCTruth")
  tuple.addTupleTool("TupleToolMCBackgroundInfo")

# Change the configuration of the TupleToolTISTOS tool
tuple.addTool(TupleToolTISTOS())
tuple.TupleToolTISTOS.TriggerList = ["Hlt1TrackAllL0Decision",
                                     "Hlt1GlobalDecision",
                                     "Hlt2CharmHadLambdaC2KPPiDecision",
                                     "Hlt2CharmHadLambdaC2KPPiWideMassDecision"]

tuple.TupleToolTISTOS.VerboseHlt1 = True
tuple.TupleToolTISTOS.VerboseHlt2 = True

# Personalise particle branch head names
tuple.addBranches({'Xiccp'      : '[Xi_cc+ -> (Lambda_c+ -> K- p+ pi+) K- pi+]CC',
                   'Lcp'        : '[Xi_cc+ -> ^(Lambda_c+ -> K- p+ pi+) K- pi+]CC',
                   'Km'         : '[Xi_cc+ -> (Lambda_c+ -> ^K- p+ pi+) K- pi+]CC',
                   'psoft'      : '[Xi_cc+ -> (Lambda_c+ -> K- ^p+ pi+) K- pi+]CC',
                   'Pip'        :  '[Xi_cc+ -> (Lambda_c+ -> K- p+ ^pi+) K- pi+]CC',
                   'Kmsoft'     :  '[Xi_cc+ -> (Lambda_c+ -> K- p+ pi+) ^K- pi+]CC',
                   'Pipsoft'    : '[Xi_cc+ -> (Lambda_c+ -> K- p+ pi+) K- ^pi+]CC'})

# Configure DecayTreeFitter with a constraint on the Lambda-c mass

Const_tool1 = tuple.Xiccp.addTupleTool('TupleToolDecayTreeFitter/ConsMass')
Const_tool1.daughtersToConstrain = ['Lambda_c+']
Const_tool1.Verbose = True

Const_tool2 = tuple.Xiccp.addTupleTool('TupleToolDecayTreeFitter/ConsPV')
Const_tool2.constrainToOriginVertex = True
Const_tool2.Verbose = True

#Configure LoKi__Hybrid__TupleTool
from Configurables import LoKi__Hybrid__TupleTool

preamble = ['DZ = VFASPF(VZ) - BPV(VZ)',
            'TRACK_MAX_PT = MAXTREE(ISBASIC & HASTRACK, PT, -1)']

variables1 = {'MAXDOCA'     :  "DOCAMAX",
              'DIRA'        :  "BPVDIRA",
              'DecayAngle'  :  "LV01",
              'P'           :  "P",
              'ETA'         :  "ETA",
              'DZ'          :  "DZ",
              'MAX_PT'      :  "TRACK_MAX_PT",
              'VTX_CHI2'    :  "VFASPF(VCHI2)",
              'VTX_VZ'      :  "VFASPF(VZ)",
              'MIPCHI2DV'   :  "MIPCHI2DV(PRIMARY)"}

variables2 = { 'P'           :  "P",
               'ETA'         :  "ETA"}

XiccpTool = tuple.Xiccp.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
XiccpTool.Preambulo = preamble
XiccpTool.Variables = variables1

LcpTool = tuple.Lcp.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
LcpTool.Preambulo = preamble
LcpTool.Variables = variables1

KmTool = tuple.Km.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
KmTool.Preambulo = preamble
KmTool.Variables = variables2

psoftTool = tuple.psoft.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
psoftTool.Preambulo = preamble
psoftTool.Variables = variables2

PipTool = tuple.Pip.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
PipTool.Preambulo = preamble
PipTool.Variables = variables2

KmsoftTool = tuple.Kmsoft.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
KmsoftTool.Preambulo = preamble
KmsoftTool.Variables = variables2

PipsoftTool = tuple.Pipsoft.addTupleTool('LoKi::Hybrid::TupleTool/XiccLoKiTuple')
PipsoftTool.Preambulo = preamble
PipsoftTool.Variables = variables2

################### CONFIGURE MCDECAY TREE TUPLE ###############################

# Using MCDecayTreeTuple to give generated information in our final ntuple
# Takes no input, stripping candidates are not passed to it as not reconstruction has taken place

mctuple = MCDecayTreeTuple()

mctuple.ToolList +=  [ 
      "MCTupleToolKinematic"
    , "MCTupleToolAngles"
    , "MCTupleToolEventType"
    , "MCTupleToolDecayType"  
    , "MCTupleToolPID"
    , "MCTupleToolPrimaries"
    , "MCTupleToolPrompt"
    , "MCTupleToolInteractions"
    , "MCTupleToolReconstructed"
    , "MCTupleToolHierarchy"]

# Search in decay "sections". allowing arbitrary number of additional photons (=>) 
# plus another (=) for Lc to ignore intermediate resonances
# Lambda-c decays usually generated with intermediate resonances, see DecFile for example

mctuple.Decay = "[Xi_cc+ => ^(Lambda_c+ ==> ^K- ^p+ ^pi+) ^K- ^pi+]CC"

# Personalise particle branch head names
mctuple.addBranches({'Xiccp'     : "[Xi_cc+ => (Lambda_c+ ==> K- p+ pi+) K- pi+]CC",
                   'Lpc'         : "[Xi_cc+ => ^(Lambda_c+ ==> K- p+ pi+) K- pi+]CC",
                   'Km'          : "[Xi_cc+ => (Lambda_c+ ==> ^K- p+ pi+) K- pi+]CC",
                   'psoft'       : "[Xi_cc+ => (Lambda_c+ ==> K- ^p+ pi+) K- pi+]CC",
                   'Pip'         : "[Xi_cc+ => (Lambda_c+ ==> K- p+ ^pi+) K- pi+]CC",
                   'Kmsoft'      : "[Xi_cc+ => (Lambda_c+ ==> K- p+ pi+) ^K- pi+]CC",
                   'Pipsoft'     : "[Xi_cc+ => (Lambda_c+ ==> K- p+ pi+) K- ^pi+]CC"})

####################### CONFIGURE DAVINCI  ###########################

from Configurables import DaVinci

dv = DaVinci()
dv.UserAlgorithms += [Seq_Xicc2LcKpi.sequence(), tuple, mctuple]

dv.DataType = '2012'
dv.InputType = 'DST'
dv.PrintFreq = 1000
dv.EvtMax =  -1          

# DDDB = Detector Description Database and CondDB = Conditions Database.

dv.DDDBtag = "dddb-20150928"
dv.CondDBtag = "sim-20160321-2-vc-md100"  # For MagDown
#dv.CondDBtag = "sim-20160321-2-vc-mu100" # For MagUp 

dv.HistogramFile = "26165058_MagDown_histos_5000events.root"   
dv.TupleFile     = "26165058_MagDown_tuple_5000events.root"
dv.Simulation = True
dv.Lumi = not dv.Simulation 

################# DEBUGGING #########################

from Configurables import GaudiSequencer
from Configurables import LoKi__HDRFilter, PrintDecayTree 

MySequencer = GaudiSequencer('Sequence')

pt = PrintDecayTree(Inputs = [ location ])
sf = LoKi__HDRFilter( 'StripPassFilter', Code="HLT_PASS('Stripping"+line+"Decision')", Location="/Event/Strip/Phys/DecReports" )

MySequencer.Members = [ sf ]

dv.appendToMainSequence([ MySequencer ])

MessageSvc().Format = "% F%60W%S%7W%R%T %0W%M"  # useful bit of coding to increase error message output

#####################################################

#from GaudiConf import IOHelper

#IOHelper().inputFiles([
#      '/afs/cern.ch/work/m/mutraill/Data/MonteCarlo/Xicc+2LcK-pi+/MagDown_00053950_00000001_2.AllStreams.dst'
#      ], clear=True)

#####################################################
